COMPILE;
DIRECTORY MASTER;
/********************************************************
*	mem-hdl						*
*	7/11/88						*
********************************************************/

/*
This module is the provides memory timing in the SLIPSTREAM chip on the ACW
*/





MODULE MEM;

INPUTS	RESETL_0,CLK,DQCLK,BMREQ,DMREQ,HLDAL,RDL,WRL,IOML,A_0,A_18,A_19,VBUSYL_0,
   VBUSYL_1,VCS,VOE,VCAS,VRAS,WD_0,WD_1,WD_2,WD_3,MEMLD,PSUEDO,BWORD,DWORD;
OUTPUTS	CAS,MUXL,WAITL,SCE_0,SCE_1,WE,DWE,CS_0,CS_1,OE;
LEVEL FUNCTION;
DEFINE

WORDL_(WORDL) = NR2A(BWORD,DWORD);
MREQL_(MREQL) = NR2A(BMREQ,DMREQ);

/* latch the memory type */

MEM_0_(MEM_0,MEML_0) = LD1A(WD_0,MEMLD);
MEM_1_(MEM_1,MEML_1) = LD1A(WD_1,MEMLD);
MEM_2_(MEM_2,MEML_2) = LD1A(WD_2,MEMLD);
MEM_3_(MEM_3,MEML_3) = LD1A(WD_3,MEMLD);

/* Using the top two bits of the address, the memory type register, and
the psuedo signal from the status register generate the current memory type.

0..ROM
1..DRAM
2..SRAM
3..PSRAM

Memory between 256k and 512k is deemed to be SRAM */

AL_18_(AL_18) = N1C(A_18);
AL_19_(AL_19) = N1C(A_19);
DEC_0_(DEC_0) = NR2A(A_18,A_19);
DEC_1_(DEC_1) = NR2A(AL_18,A_19);
DEC_2_(DEC_2) = NR2A(A_18,AL_19);
DEC_3_(DEC_3) = NR2A(AL_18,AL_19);

T00_(T00) = ND2A(DEC_0,PSUEDO);
T01_(T01) = ND2A(DEC_2,MEM_0);
T02_(T02) = ND2A(DEC_3,MEM_2);

TYPE_0_(TYPE_0) = ND3C(T00,T01,T02);

T10_(T10) = N1A(DEC_0);
T11_(T11) = ND2A(DEC_2,MEM_1);
T12_(T12) = ND2A(DEC_3,MEM_3);
T13_(T13) = N1A(DEC_1);

TYPE_1_(TYPE_1) = ND4C(T10,T11,T12,T13);
TYPEL_1_(TYPEL_1) = N1C(TYPE_1);

/* Memory timing is generated by a three state machine
however in order to achieve the resolution required for

1) psuedo static chip enable
2) screen ram write strobe
3) dram address multiplexer

the 17MHz clock is used to generate certain signals.*/

/* Decode host memory cycle request */

RDWR_(RDWR) = ND2C(RDL,WRL);
HREQ_(HREQL) = ND2A(IOML,RDWR);

/* generate combined memory cycle request */

HLDA_(HLDA) = N1A(HLDAL);
MEMREQ_(MEMREQ) = AO2C(HLDA,MREQL,HLDAL,HREQL);
XREQL_(XREQL) = ND2A(HLDAL,IOML);
REQ_(REQ) = ND2C(MREQL,XREQL);

/* the next state is defined by the current state and the signals
resetL, memreq, type[1], vbusy[0] and vbusy[1] as follows :-


	State	Q's	R M T V0 V1	Next	D's
	--------------------------------------------
	X	XX	L X X X  X	0	00	reset

	0	00	H L X X  X	0	00	idle
	0	00	H H L H  X	0	00
	0	00	H H L L  X	1	01
	0	00	H H H X  H	0	00
	0	00	H H H X  L	2	11

	1	01	H X X X  X	2	11	ROM/DRAM access

	2	11	H H X X  X	2	11	Screen access
	2	11	H L X X  X	0	00
*/

/* buffer the clocks & reset */

CLKL_(CLKL) = N1C(CLK);
RESET_(RESETL) = B3A(RESETL_0);
VBUSYL_0_(VBUSY_0) = N1C(VBUSYL_0);
VBUSYL_1_(VBUSY_1) = N1C(VBUSYL_1);

Q_0_(Q_0,QB_0) = FD2A(D_0,CLK,RESETL);
Q_1_(Q_1,QB_1) = FD2A(D_1,CLK,RESETL);

MT_0_(MT_0) = ND6A(RESETL,QB_0,QB_1,MEMREQ,TYPEL_1,VBUSYL_0);
MT_1_(MT_1) = ND6A(RESETL,QB_0,QB_1,MEMREQ,TYPE_1,VBUSYL_1);
MT_2_(MT_2) = ND3A(RESETL,Q_0,QB_1);
MT_3_(MT_3) = ND4A(RESETL,Q_0,Q_1,MEMREQ);

D_0_(D_0) = ND4A(MT_0,MT_1,MT_2,MT_3);
D_1_(D_1) = ND3A(MT_1,MT_2,MT_3);

/* produce pulses synchronized to clkL at the start of every cycle.
These are used in the generation of sce,soe,we,ras
start1 is one cycle long */

QREQL_0_(QREQL_0) = ND4A(RDWR,AL_19,REQ,VBUSYL_1);
QREQL_1_(QREQL_1) = ND6A(RDWR,A_19,AL_18,MEM_1,REQ,VBUSYL_1);
QREQL_2_(QREQL_2) = ND6A(RDWR,A_19,A_18,MEM_3,REQ,VBUSYL_1);
SREQL_0_(SREQL_0) = ND6A(RDWR,A_19,AL_18,MEML_1,REQ,VBUSYL_0);
SREQL_1_(SREQL_1) = ND6A(RDWR,A_19,A_18,MEML_3,REQ,VBUSYL_0);
REQ_0_(REQ_0) = ND5A(QREQL_0,QREQL_1,QREQL_2,SREQL_0,SREQL_1);

REQ_1_(REQ_1,REQL_1) = FD2A(REQ_0,CLKL,RESETL);

REQ_2_(REQ_2,REQL_2) = FD2A(REQ_1,CLKL,RESETL);


START1L_(START1L) = ND2C(REQ_1,REQL_2);
START1_(START1) = N1C(START1L);


/* from the above we must generate timing for:-

romcs,ras,cas,mux,sce,soe,oe,we

romcs timing is as rdl
ras is start1 + mux 
cas is (req1 + state1 or (state2 and memreq)) sampled by clk
mux is start1 sampled by dqclk
psce is start1 + cas
psoe is as psce
we is as ras

*/

DQCLKL_(DQCLKL) = N1A(DQCLK);
MUXD_(MUXDL,MUXD) = FD4A(START1L,DQCLKL,RESETL);

RASD_(RASD) = ND2C(START1L,MUXDL);
CASD_(CASD) = ND3A(REQL_1,MT_2,MT_3);
CAST_(CAST,CASTL) = FD2A(CASD,CLK,RESETL);

CASTL_0_(CASTL_0) = ND5A(AL_18,A_19,MEM_0,MEML_1,CAST);
CASTL_1_(CASTL_1) = ND5A(A_18,A_19,MEM_2,MEML_3,CAST);
VCASL_(VCASL) = N1A(VCAS);
CAS_(CAS) = ND3A(CASTL_0,CASTL_1,VCASL);

DRAM_(DRAM) = AND2A(TYPE_0,TYPEL_1);
MUXL_(MUXL) = ND2C(DRAM,MUXD);

/* generate the timing for screen chip select/output enable */

PSCE_(PSCE) = ND2C(START1L,CASTL);

/* generate the address decode for screen chip selects */
/* combine address decode with timing */

AL_0_(AL_0) = N1A(A_0);

WORD_(WORD) = N1A(WORDL);
WIDEPL_(WIDEPL) = ND5A(WORD,HLDA,AL_18,AL_19,PSCE);
ODDPL_(ODDPL) = ND5A(IOML,AL_18,AL_19,A_0,PSCE);
EVENPL_(EVENPL) = ND5A(IOML,AL_18,AL_19,AL_0,PSCE);
VCSL_(VCSL) = N1C(VCS);

SCE_0_(SCE_0) = ND3A(WIDEPL,EVENPL,VCSL);
SCE_1_(SCE_1) = ND3A(WIDEPL,ODDPL,VCSL);

WEL_(WEL) = NR2A(START1,MUXD);
WE_(WE) = NR2A(WRL,WEL);

/* combine address decode with timing */

RASL_0_(RASL_0) = ND5A(AL_18,A_19,MEM_0,MEML_1,RASD);
RASL_1_(RASL_1) = ND5A(A_18,A_19,MEM_2,MEML_3,RASD);
PSCEL_0_(PSCEL_0) = ND5A(AL_18,A_19,MEM_0,MEM_1,PSCE);
PSCEL_1_(PSCEL_1) = ND5A(A_18,A_19,MEM_2,MEM_3,PSCE);
RDWRL_0_(RDWRL_0) = ND4A(AL_18,A_19,MEML_0,PSCE);
RDWRL_1_(RDWRL_1) = ND4A(A_18,A_19,MEML_2,PSCE);

/* generate refresh RAS if dram installed */

VRASL_0_(VRASL_0) = ND3A(VRAS,MEM_0,MEML_1);
VRASL_1_(VRASL_1) = ND3A(VRAS,MEM_2,MEML_3);

/* combine refresh RAS and chip select */

CS_0_(CS_0) = ND4C(VRASL_0,RASL_0,PSCEL_0,RDWRL_0);
CS_1_(CS_1) = ND4C(VRASL_1,RASL_1,PSCEL_1,RDWRL_1);

/* generate output enable timing */

RD_(RD) = N1A(RDL);
VOEL_(VOEL) = N1A(VOE);
PSCEL_(PSCEL) = ND2A(PSCE,RD);
OE_(OE) = ND2A(PSCEL,VOEL);

/* generate wait */
/* vbusy[0] is asserted when it is too late to start a ROM/DRAM cycle */
/* vbusy[1] is asserted when it is too late to start any cycle */
/* wait is also asserted during ROM/DRAM cycles */

ZERO_(ZERO) = NR2A(Q_0,Q_1);
WAITL_0_(WAITL_0) = ND4A(MEMREQ,TYPEL_1,ZERO,VBUSY_0);
WAITL_1_(WAITL_1) = ND4A(MEMREQ,TYPE_1,ZERO,VBUSY_1);
WAITL_(WAITL) = AND3A(WAITL_0,WAITL_1,MT_0);

/* generate a synchronous write strobe for the dsp */

WR_1_(WRL_1,WR_1) = FD2A(WRL,CLK,RESETL);

WR_2_(WR_2,WRL_2) = FD2A(WR_1,CLK,RESETL);

DWE_(DWE) = NR2A(WRL_1,WR_2);


END MODULE;

END COMPILE;
END;
