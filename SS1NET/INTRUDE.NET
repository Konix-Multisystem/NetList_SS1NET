COMPILE;
DIRECTORY MASTER;

MODULE INTRUDE;

INPUTS	HD_0,HD_1,HD_2,HD_3,HD_4,HD_5,HD_6,HD_7,
   DDB_0,DDB_1,DDB_2,DDB_3,DDB_4,DDB_5,DDB_6,DDB_7,
   DDB_8,DDB_9,DDB_10,DDB_11,DDB_12,DDB_13,DDB_14,DDB_15,HA_0,HA_9,HA_10,DCSL,RDL,WRL,INTRUD,
   CLK,DQCLK,RESETL;
OUTPUTS	HD_0,HD_1,HD_2,HD_3,HD_4,HD_5,HD_6,HD_7,D_0,D_1,D_2,D_3,D_4,D_5,D_6,D_7,
   D_8,D_9,D_10,D_11,D_12,D_13,D_14,D_15,RUN,RUNANT,TRURD,INTRALDL;
LEVEL FUNCTION;
DEFINE

/* The Intrude register */

INTRU_0_(OUP_0,OUPL_0) = LD1A(INP_0,WRLO);
INTRU_1_(OUP_1,OUPL_1) = LD1A(INP_1,WRLO);
INTRU_2_(OUP_2,OUPL_2) = LD1A(INP_2,WRLO);
INTRU_3_(OUP_3,OUPL_3) = LD1A(INP_3,WRLO);
INTRU_4_(OUP_4,OUPL_4) = LD1A(INP_4,WRLO);
INTRU_5_(OUP_5,OUPL_5) = LD1A(INP_5,WRLO);
INTRU_6_(OUP_6,OUPL_6) = LD1A(INP_6,WRLO);
INTRU_7_(OUP_7,OUPL_7) = LD1A(INP_7,WRLO);
INTRU_8_(OUP_8,OUPL_8) = LD1A(INP_8,WRHI);
INTRU_9_(OUP_9,OUPL_9) = LD1A(INP_9,WRHI);
INTRU_10_(OUP_10,OUPL_10) = LD1A(INP_10,WRHI);
INTRU_11_(OUP_11,OUPL_11) = LD1A(INP_11,WRHI);
INTRU_12_(OUP_12,OUPL_12) = LD1A(INP_12,WRHI);
INTRU_13_(OUP_13,OUPL_13) = LD1A(INP_13,WRHI);
INTRU_14_(OUP_14,OUPL_14) = LD1A(INP_14,WRHI);
INTRU_15_(OUP_15,OUPL_15) = LD1A(INP_15,WRHI);

/* Decode the write signals .... */

WRHI_(WRHI) = NR2C(WRHIL,DQCLK);
WRLO_(WRLO) = NR2C(WRLOL,DQCLK);

WRHIL_(WRHIL) = NR2A(HTRUWRHI,TRUWR);
WRLOL_(WRLOL) = NR2A(HTRUWRLO,TRUWR);

/* The DSP may write into the INTRUDE register UNLESS the write cycle is
   in progress or the Read cycle has gone beyond state 2.

   ie. writes are only allowed in states 0000, 0001 and 0010. */

TRUWR_(TRUWR) = ND2A(TRUWR1L,TRUWR2L);
TRUWR1L_(TRUWR1L) = ND4A(INTRUDL_0,INTRUDL_2,INTRUDL_3,INTRUD);
TRUWR2L_(TRUWR2L) = ND4A(INTRUDL_1,INTRUDL_2,INTRUDL_3,INTRUD);


/* Enable this onto the DSP data bus */

DDAT_0_(D_0) = BTS5B(OUPL_0,TRURD);
DDAT_1_(D_1) = BTS5B(OUPL_1,TRURD);
DDAT_2_(D_2) = BTS5B(OUPL_2,TRURD);
DDAT_3_(D_3) = BTS5B(OUPL_3,TRURD);
DDAT_4_(D_4) = BTS5B(OUPL_4,TRURD);
DDAT_5_(D_5) = BTS5B(OUPL_5,TRURD);
DDAT_6_(D_6) = BTS5B(OUPL_6,TRURD);
DDAT_7_(D_7) = BTS5B(OUPL_7,TRURD);
DDAT_8_(D_8) = BTS5B(OUPL_8,TRURD);
DDAT_9_(D_9) = BTS5B(OUPL_9,TRURD);
DDAT_10_(D_10) = BTS5B(OUPL_10,TRURD);
DDAT_11_(D_11) = BTS5B(OUPL_11,TRURD);
DDAT_12_(D_12) = BTS5B(OUPL_12,TRURD);
DDAT_13_(D_13) = BTS5B(OUPL_13,TRURD);
DDAT_14_(D_14) = BTS5B(OUPL_14,TRURD);
DDAT_15_(D_15) = BTS5B(OUPL_15,TRURD);

/* And onto the host data bus */

HDHI_0_(HD_0) = BTS4A(OUP_8,HTRURDHI);
HDHI_1_(HD_1) = BTS4A(OUP_9,HTRURDHI);
HDHI_2_(HD_2) = BTS4A(OUP_10,HTRURDHI);
HDHI_3_(HD_3) = BTS4A(OUP_11,HTRURDHI);
HDHI_4_(HD_4) = BTS4A(OUP_12,HTRURDHI);
HDHI_5_(HD_5) = BTS4A(OUP_13,HTRURDHI);
HDHI_6_(HD_6) = BTS4A(OUP_14,HTRURDHI);
HDHI_7_(HD_7) = BTS4A(OUP_15,HTRURDHI);
HDLO_0_(HD_0) = BTS4A(OUP_0,HTRURDLO);
HDLO_1_(HD_1) = BTS4A(OUP_1,HTRURDLO);
HDLO_2_(HD_2) = BTS4A(OUP_2,HTRURDLO);
HDLO_3_(HD_3) = BTS4A(OUP_3,HTRURDLO);
HDLO_4_(HD_4) = BTS4A(OUP_4,HTRURDLO);
HDLO_5_(HD_5) = BTS4A(OUP_5,HTRURDLO);
HDLO_6_(HD_6) = BTS4A(OUP_6,HTRURDLO);
HDLO_7_(HD_7) = BTS4A(OUP_7,HTRURDLO);

/* Multiplex the two sources onto the latch. Unless the host is
   writing (hostwrL is LOW), then DSP data is always directed to the latch
   input.    */

INP_0_(INP_0) = MUX(DDB_0,HOSTWRL,HD_0,HOSTWR);
INP_1_(INP_1) = MUX(DDB_1,HOSTWRL,HD_1,HOSTWR);
INP_2_(INP_2) = MUX(DDB_2,HOSTWRL,HD_2,HOSTWR);
INP_3_(INP_3) = MUX(DDB_3,HOSTWRL,HD_3,HOSTWR);
INP_4_(INP_4) = MUX(DDB_4,HOSTWRL,HD_4,HOSTWR);
INP_5_(INP_5) = MUX(DDB_5,HOSTWRL,HD_5,HOSTWR);
INP_6_(INP_6) = MUX(DDB_6,HOSTWRL,HD_6,HOSTWR);
INP_7_(INP_7) = MUX(DDB_7,HOSTWRL,HD_7,HOSTWR);
INP_8_(INP_8) = MUX(DDB_8,HOSTWRL,HD_0,HOSTWR);
INP_9_(INP_9) = MUX(DDB_9,HOSTWRL,HD_1,HOSTWR);
INP_10_(INP_10) = MUX(DDB_10,HOSTWRL,HD_2,HOSTWR);
INP_11_(INP_11) = MUX(DDB_11,HOSTWRL,HD_3,HOSTWR);
INP_12_(INP_12) = MUX(DDB_12,HOSTWRL,HD_4,HOSTWR);
INP_13_(INP_13) = MUX(DDB_13,HOSTWRL,HD_5,HOSTWR);
INP_14_(INP_14) = MUX(DDB_14,HOSTWRL,HD_6,HOSTWR);
INP_15_(INP_15) = MUX(DDB_15,HOSTWRL,HD_7,HOSTWR);


/* Decode the Host Intrude transactions */

HTRURDHI_(HTRURDHI) = NR4B(DCSL,RDL,HAL_0,HA_10);
HTRURDLO_(HTRURDLO) = NR4B(DCSL,RDL,HA_0,HA_10);
HOSTRD_(HOSTRD) = NR3B(DCSL,RDL,HA_10);
HAL_0_(HAL_0) = N1A(HA_0);
HAL_10_(HAL_10) = N1A(HA_10);
HAL_9_(HAL_9) = N1A(HA_9);

HTRUWRHI_(HTRUWRHI) = NR4A(DCSL,WRL,HAL_0,HA_10);
HTRWRLO_(HTRUWRLO) = NR4A(DCSL,WRL,HA_0,HA_10);
HOSTWR_(HOSTWR) = NR3C(DCSL,WRL,HA_10);
HOSTWRL_(HOSTWRL) = N1C(HOSTWR);
INTRALDL_(INTRALDL) = NR2C(HOSTWR,HOSTRD);


/* include the state machine */


INTRUDE_(INTRUD_0,INTRUD_1,INTRUD_2,INTRUD_3,INTRUDL_0,INTRUDL_1,INTRUDL_2,
   INTRUDL_3) = RUDMC(HOSTWR,CLK,RESETL,HOSTRD,INTRUD);


/* The contents of the INTRUDE register are enabled onto the DSP data bus 
	and the write
	enable for the RAM (or other internal location) become active
	during when the machine has reached its final state (1100) and
	there is a current INTRUDE instruction.	*/

TRURD_(TRURD) = AND3C(INTRUD_2,INTRUD_3,INTRUD);


/* The RUN/STATUS register */

RUNEN_(RUNEN) = OR4A(HAL_10,HAL_9,DCSL,WRL);
STATEN_(STATEN) = NR4C(HAL_10,HAL_9,DCSL,RDL);

RUNBIT_(RUNBIT,RUNBITL) = FD2A(HD_4,RUNEN,RESETL);

/* The status bits are as follows */

STATUS_0_(HD_0) = BTS5A(INTRUDL_0,STATEN);
STATUS_1_(HD_1) = BTS5A(INTRUDL_1,STATEN);
STATUS_2_(HD_2) = BTS5A(INTRUDL_2,STATEN);
STATUS_3_(HD_3) = BTS5A(INTRUDL_3,STATEN);
STATUS_4_(HD_4) = BTS5A(RUNL,STATEN);
STATUS_5_(HD_5) = BTS5A(RESETL,STATEN);
STATUS_6_(HD_6) = BTS5A(RESETL,STATEN);
STATUS_7_(HD_7) = BTS5A(RESETL,STATEN);
/* Run is also the cycle AFTER the RUN register has been written to */

STEP_1_(STEP_1,STEPL_1) = FD2A(RUNEN,CLK,RESETL);
STEP_2_(STEP_2,STEPL_2) = FD2A(STEP_1,CLK,RESETL);

STEP_3_(STEP_3) = NR2A(STEP_1,STEPL_2);

/* combine the two ..*/

RUNANT_(RUNANT) = OR2A(STEP_3,RUNBIT);
RUN_(RUN,RUNL) = FD2A(RUNANT,CLK,RESETL);
END MODULE;

MODULE RUDMC;

INPUTS	WR,CLK,RESETL,RD,TRUDY;
OUTPUTS	I_0,I_1,I_2,I_3,IL_0,IL_1,IL_2,IL_3;
LEVEL FUNCTION;
DEFINE

I_0_(I_0,IL_0) = FD2A(X_0,CLK,RESETL);
I_1_(I_1,IL_1) = FD2A(X_1,CLK,RESETL);
I_2_(I_2,IL_2) = FD2A(X_2,CLK,RESETL);
I_3_(I_3,IL_3) = FD2A(X_3,CLK,RESETL);

TER_1_(TER_1) = ND4A(IL_3,IL_1,IL_0,RD);
TER_2_(TER_2) = ND4A(IL_3,I_2,IL_0,RD);
TER_3_(TER_3) = ND3A(IL_3,I_0,RD);
TER_4_(TER_4) = ND3A(IL_2,IL_0,WR);
TER_5_(TER_5) = ND3A(I_3,I_0,WR);

TER_6_(TER_6) = ND4A(IL_3,IL_1,I_0,RDL);
TER_7_(TER_7) = ND4A(IL_3,IL_2,I_1,TRUDYL);
TER_8_(TER_8) = ND3A(I_2,I_1,IL_0);
TER_9_(TER_9) = ND5A(IL_3,I_2,I_1,I_0,RD);
TER_10_(TER_10) = ND5A(I_3,IL_2,IL_1,I_0,WRL);
TER_17_(TER_17) = ND3A(I_3,I_1,IL_0);

TER_11_(TER_11) = ND5A(IL_3,IL_2,I_1,IL_0,TRUDY);
TER_12_(TER_12) = ND3A(IL_3,I_2,IL_1);
TER_13_(TER_13) = ND5A(I_3,IL_2,I_1,I_0,WRL);
TER_14_(TER_14) = ND3A(I_3,I_2,TRUDYL);

TER_15_(TER_15) = ND4A(IL_2,IL_1,IL_0,WR);
TER_16_(TER_16) = ND2A(I_3,IL_2);


X_0_(X_0) = ND5A(TER_1,TER_2,TER_3,TER_4,TER_5);
X_1_(X_1) = ND6A(TER_6,TER_7,TER_8,TER_9,TER_10,TER_17);
X_2_(X_2) = ND6A(TER_11,TER_12,TER_13,TER_14,TER_8,TER_9);
X_3_(X_3) = ND3A(TER_14,TER_15,TER_16);


RDL_(RDL) = N1A(RD);
WRL_(WRL) = N1A(WR);
TRUDYL_(TRUDYL) = N1A(TRUDY);

END MODULE;






END COMPILE;
END;
