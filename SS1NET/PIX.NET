COMPILE;
DIRECTORY MASTER;
/********************************************************
*	pix-hdl						*
*	4/11/88						*
********************************************************/

/*
This module is the pixel generator in the SLIPSTREAM chip on the ACW
*/





MODULE PIX;

INPUTS	D_0,D_1,D_2,D_3,D_4,D_5,D_6,D_7,P7L_0,P7L_1,P7L_2,P7L_3,P7L_4,P7L_5,
   P7L_6,P7L_7,P7L_8,P7L_9,P7L_10,P7L_11,P7L_12,P7L_13,P7L_14,P7L_15,RESETL_0,
   CLK,WD_0,WD_1,WD_2,WD_3,WD_4,WD_5,WD_6,WD_7,MODE,BORDL,BORDH,TRANS,MASK,
   INDEX,BORDER,BLANKING,HC_0,HC_1,A_0,A_1,A_2,A_3,A_4,A_5,A_6,A_7,A_8,RDL,WRL,
   WE,PALCS,PIXLD_0,PIXLD_1,PIXAD_0,PIXAD_1,TMODE,IDL_0,IDL_1,IDL_2,IDL_3,IDL_4,
   IDL_5,IDL_6,IDL_7,IDL_8,IDL_9,IDL_10,IDL_11,IDL_12,IDL_13,IDL_14,IDL_15;
OUTPUTS	D_0,D_1,D_2,D_3,D_4,D_5,D_6,D_7,P7L_0,P7L_1,P7L_2,P7L_3,P7L_4,P7L_5,
   P7L_6,P7L_7,P7L_8,P7L_9,P7L_10,P7L_11,P7L_12,P7L_13,P7L_14,P7L_15,RL_0,RL_1,
   RL_2,RL_3,GL_0,GL_1,GL_2,GL_3,BL_0,BL_1,BL_2,BL_3,INC_2,MODE_0,MODE_1,
   GENLOCK,LORES,NOWRAP,PA_0,PA_1,PA_2,PA_3,PA_4,PA_5,PA_6,PA_7,POE,PWE,PCS;
LEVEL FUNCTION;
DEFINE

RES_(RES) = N1A(RESETL_0);
RESL_(RESL) = N1C(RES);

/* latch the 16 bit pixel data */

PIX0_0_(PIX0B_0,PIX0_0) = FD2A(IDL_0,PIXLD_0,RESL);
PIX0_1_(PIX0B_1,PIX0_1) = FD2A(IDL_1,PIXLD_0,RESL);
PIX0_2_(PIX0B_2,PIX0_2) = FD2A(IDL_2,PIXLD_0,RESL);
PIX0_3_(PIX0B_3,PIX0_3) = FD2A(IDL_3,PIXLD_0,RESL);
PIX0_4_(PIX0B_4,PIX0_4) = FD2A(IDL_4,PIXLD_0,RESL);
PIX0_5_(PIX0B_5,PIX0_5) = FD2A(IDL_5,PIXLD_0,RESL);
PIX0_6_(PIX0B_6,PIX0_6) = FD2A(IDL_6,PIXLD_0,RESL);
PIX0_7_(PIX0B_7,PIX0_7) = FD2A(IDL_7,PIXLD_0,RESL);
PIX1_0_(PIX1B_0,PIX1_0) = FD2A(IDL_8,PIXLD_0,RESL);
PIX1_1_(PIX1B_1,PIX1_1) = FD2A(IDL_9,PIXLD_0,RESL);
PIX1_2_(PIX1B_2,PIX1_2) = FD2A(IDL_10,PIXLD_0,RESL);
PIX1_3_(PIX1B_3,PIX1_3) = FD2A(IDL_11,PIXLD_0,RESL);
PIX1_4_(PIX1B_4,PIX1_4) = FD2A(IDL_12,PIXLD_0,RESL);
PIX1_5_(PIX1B_5,PIX1_5) = FD2A(IDL_13,PIXLD_0,RESL);
PIX1_6_(PIX1B_6,PIX1_6) = FD2A(IDL_14,PIXLD_0,RESL);
PIX1_7_(PIX1B_7,PIX1_7) = FD2A(IDL_15,PIXLD_0,RESL);
PIX2_0_(PIX2B_0,PIX2_0) = FD2A(IDL_0,PIXLD_1,RESL);
PIX2_1_(PIX2B_1,PIX2_1) = FD2A(IDL_1,PIXLD_1,RESL);
PIX2_2_(PIX2B_2,PIX2_2) = FD2A(IDL_2,PIXLD_1,RESL);
PIX2_3_(PIX2B_3,PIX2_3) = FD2A(IDL_3,PIXLD_1,RESL);
PIX2_4_(PIX2B_4,PIX2_4) = FD2A(IDL_4,PIXLD_1,RESL);
PIX2_5_(PIX2B_5,PIX2_5) = FD2A(IDL_5,PIXLD_1,RESL);
PIX2_6_(PIX2B_6,PIX2_6) = FD2A(IDL_6,PIXLD_1,RESL);
PIX2_7_(PIX2B_7,PIX2_7) = FD2A(IDL_7,PIXLD_1,RESL);
PIX3_0_(PIX3B_0,PIX3_0) = FD2A(IDL_8,PIXLD_1,RESL);
PIX3_1_(PIX3B_1,PIX3_1) = FD2A(IDL_9,PIXLD_1,RESL);
PIX3_2_(PIX3B_2,PIX3_2) = FD2A(IDL_10,PIXLD_1,RESL);
PIX3_3_(PIX3B_3,PIX3_3) = FD2A(IDL_11,PIXLD_1,RESL);
PIX3_4_(PIX3B_4,PIX3_4) = FD2A(IDL_12,PIXLD_1,RESL);
PIX3_5_(PIX3B_5,PIX3_5) = FD2A(IDL_13,PIXLD_1,RESL);
PIX3_6_(PIX3B_6,PIX3_6) = FD2A(IDL_14,PIXLD_1,RESL);
PIX3_7_(PIX3B_7,PIX3_7) = FD2A(IDL_15,PIXLD_1,RESL);

/* select one of four bytes */

P0_0_(P0_0) = MUX4(PIXAD_0,PIXAD_1,PIX0_0,PIX1_0,PIX2_0,PIX3_0);
P0_1_(P0_1) = MUX4(PIXAD_0,PIXAD_1,PIX0_1,PIX1_1,PIX2_1,PIX3_1);
P0_2_(P0_2) = MUX4(PIXAD_0,PIXAD_1,PIX0_2,PIX1_2,PIX2_2,PIX3_2);
P0_3_(P0_3) = MUX4(PIXAD_0,PIXAD_1,PIX0_3,PIX1_3,PIX2_3,PIX3_3);
P0_4_(P0_4) = MUX4(PIXAD_0,PIXAD_1,PIX0_4,PIX1_4,PIX2_4,PIX3_4);
P0_5_(P0_5) = MUX4(PIXAD_0,PIXAD_1,PIX0_5,PIX1_5,PIX2_5,PIX3_5);
P0_6_(P0_6) = MUX4(PIXAD_0,PIXAD_1,PIX0_6,PIX1_6,PIX2_6,PIX3_6);
P0_7_(P0_7) = MUX4(PIXAD_0,PIXAD_1,PIX0_7,PIX1_7,PIX2_7,PIX3_7);

/* select low or high nibble */

LORESL_(LORESL) = N1A(LORES);
LONIB_(LONIB) = AO2A(LORES,HC_1,LORESL,HC_0);
HINIB_(HINIB) = N1A(LONIB);
P1L_0_(P1L_0) = AO2A(LONIB,P0_0,HINIB,P0_4);
P1L_1_(P1L_1) = AO2A(LONIB,P0_1,HINIB,P0_5);
P1L_2_(P1L_2) = AO2A(LONIB,P0_2,HINIB,P0_6);
P1L_3_(P1L_3) = AO2A(LONIB,P0_3,HINIB,P0_7);
P1_0_(P1_0) = N1A(P1L_0);
P1_1_(P1_1) = N1A(P1L_1);
P1_2_(P1_2) = N1A(P1L_2);
P1_3_(P1_3) = N1A(P1L_3);

/* select byte or nibble */
/* If variable resolution mode the select signal is taken from
bit 7 of the pixel */
/* NB where nibbles are used the top four bits become zero */

BYTE_(BYTE) = AO2B(VARRES,P0_7,VARRESL,MEDRESL);
NIBBLE_(NIBBLE) = N1A(BYTE);

P2L_0_(P2L_0) = AO2A(BYTE,P0_0,NIBBLE,P1_0);
P2L_1_(P2L_1) = AO2A(BYTE,P0_1,NIBBLE,P1_1);
P2L_2_(P2L_2) = AO2A(BYTE,P0_2,NIBBLE,P1_2);
P2L_3_(P2L_3) = AO2A(BYTE,P0_3,NIBBLE,P1_3);
P2L_4_(P2L_4) = AO2A(BYTE,P0_4,NIBBLE,RES);
P2L_5_(P2L_5) = AO2A(BYTE,P0_5,NIBBLE,RES);
P2L_6_(P2L_6) = AO2A(BYTE,P0_6,NIBBLE,RES);
P2L_7_(P2L_7) = AO2A(BYTE,P0_7,NIBBLE,RES);

/* latch the border colour */

BC_0_(BC_0,BCB_0) = LD1A(WD_0,BORDL);
BC_1_(BC_1,BCB_1) = LD1A(WD_1,BORDL);
BC_2_(BC_2,BCB_2) = LD1A(WD_2,BORDL);
BC_3_(BC_3,BCB_3) = LD1A(WD_3,BORDL);
BC_4_(BC_4,BCB_4) = LD1A(WD_4,BORDL);
BC_5_(BC_5,BCB_5) = LD1A(WD_5,BORDL);
BC_6_(BC_6,BCB_6) = LD1A(WD_6,BORDL);
BC_7_(BC_7,BCB_7) = LD1A(WD_7,BORDL);
BC_8_(BC_8,BCB_8) = LD1A(WD_0,BORDH);
BC_9_(BC_9,BCB_9) = LD1A(WD_1,BORDH);
BC_10_(BC_10,BCB_10) = LD1A(WD_2,BORDH);
BC_11_(BC_11,BCB_11) = LD1A(WD_3,BORDH);
BC_12_(BC_12,BCB_12) = LD1A(WD_4,BORDH);
BC_13_(BC_13,BCB_13) = LD1A(WD_5,BORDH);
BC_14_(BC_14,BCB_14) = LD1A(WD_6,BORDH);
BC_15_(BC_15,BCB_15) = LD1A(WD_7,BORDH);

/* latch the nibble hold mode */

HOLD4_(HOLD4,HOLD4L) = LD1A(WD_0,TRANS);

/* compare colour with zero */

ZERO4_(ZERO4) = AND4A(P2L_0,P2L_1,P2L_2,P2L_3);
ZERO8_(ZERO8) = MACAND8(P2L_0,P2L_1,P2L_2,P2L_3,P2L_4,P2L_5,P2L_6,P2L_7);

/* use previous byte or nibble if zero and mode demands */

PREV8L_(PREV8L) = ND2A(HOLD8,ZERO8);
PREV8_(PREV8) = N1A(PREV8L);
PREV4L_(PREV4L) = AO2A(HOLD8,ZERO8,HOLD4,ZERO4);
PREV4_(PREV4) = N1A(PREV4L);

P4L_0_(P4_0) = AO2A(PREV4,P5L_0,PREV4L,P2L_0);
P4L_1_(P4_1) = AO2A(PREV4,P5L_1,PREV4L,P2L_1);
P4L_2_(P4_2) = AO2A(PREV4,P5L_2,PREV4L,P2L_2);
P4L_3_(P4_3) = AO2A(PREV4,P5L_3,PREV4L,P2L_3);
P4L_4_(P4_4) = AO2A(PREV8,P5L_4,PREV8L,P2L_4);
P4L_5_(P4_5) = AO2A(PREV8,P5L_5,PREV8L,P2L_5);
P4L_6_(P4_6) = AO2A(PREV8,P5L_6,PREV8L,P2L_6);
P4L_7_(P4_7) = AO2A(PREV8,P5L_7,PREV8L,P2L_7);

/* latch the pixel to store previous pixel and re-sync pixels */

P5_0_(P5_0,P5L_0) = FD2A(P4_0,CLK,RESL);
P5_1_(P5_1,P5L_1) = FD2A(P4_1,CLK,RESL);
P5_2_(P5_2,P5L_2) = FD2A(P4_2,CLK,RESL);
P5_3_(P5_3,P5L_3) = FD2A(P4_3,CLK,RESL);
P5_4_(P5_4,P5L_4) = FD2A(P4_4,CLK,RESL);
P5_5_(P5_5,P5L_5) = FD2A(P4_5,CLK,RESL);
P5_6_(P5_6,P5L_6) = FD2A(P4_6,CLK,RESL);
P5_7_(P5_7,P5L_7) = FD2A(P4_7,CLK,RESL);

/* latch the colour mask */

M_0_(M_0,MB_0) = LD1A(WD_0,MASK);
M_1_(M_1,MB_1) = LD1A(WD_1,MASK);
M_2_(M_2,MB_2) = LD1A(WD_2,MASK);
M_3_(M_3,MB_3) = LD1A(WD_3,MASK);
M_4_(M_4,MB_4) = LD1A(WD_4,MASK);
M_5_(M_5,MB_5) = LD1A(WD_5,MASK);
M_6_(M_6,MB_6) = LD1A(WD_6,MASK);
M_7_(M_7,MB_7) = LD1A(WD_7,MASK);

/* latch the colour index */

I_0_(I_0,IB_0) = LD1A(WD_0,INDEX);
I_1_(I_1,IB_1) = LD1A(WD_1,INDEX);
I_2_(I_2,IB_2) = LD1A(WD_2,INDEX);
I_3_(I_3,IB_3) = LD1A(WD_3,INDEX);
I_4_(I_4,IB_4) = LD1A(WD_4,INDEX);
I_5_(I_5,IB_5) = LD1A(WD_5,INDEX);
I_6_(I_6,IB_6) = LD1A(WD_6,INDEX);
I_7_(I_7,IB_7) = LD1A(WD_7,INDEX);

/* select either the index or the pixel */

P6_0_(P6_0) = AO2A(M_0,IB_0,MB_0,P5L_0);
P6_1_(P6_1) = AO2A(M_1,IB_1,MB_1,P5L_1);
P6_2_(P6_2) = AO2A(M_2,IB_2,MB_2,P5L_2);
P6_3_(P6_3) = AO2A(M_3,IB_3,MB_3,P5L_3);
P6_4_(P6_4) = AO2A(M_4,IB_4,MB_4,P5L_4);
P6_5_(P6_5) = AO2A(M_5,IB_5,MB_5,P5L_5);
P6_6_(P6_6) = AO2A(M_6,IB_6,MB_6,P5L_6);
P6_7_(P6_7) = AO2A(M_7,IB_7,MB_7,P5L_7);

/* look up the physical colour in the palette */
/* latch even palette data..so it can be written during odd writes */

PED_0_(PED_0,PEDL_0) = LD1A(D_0,EVEN);
PED_1_(PED_1,PEDL_1) = LD1A(D_1,EVEN);
PED_2_(PED_2,PEDL_2) = LD1A(D_2,EVEN);
PED_3_(PED_3,PEDL_3) = LD1A(D_3,EVEN);
PED_4_(PED_4,PEDL_4) = LD1A(D_4,EVEN);
PED_5_(PED_5,PEDL_5) = LD1A(D_5,EVEN);
PED_6_(PED_6,PEDL_6) = LD1A(D_6,EVEN);
PED_7_(PED_7,PEDL_7) = LD1A(D_7,EVEN);
EVEN_(EVEN) = AND3A(PALCS,WE,AL_0);

PALCSL_(PALCSL) = N1C(PALCS);
PA_0_(PA_0) = AO2A(PALCSL,P6_0,PALCS,A_1);
PA_1_(PA_1) = AO2A(PALCSL,P6_1,PALCS,A_2);
PA_2_(PA_2) = AO2A(PALCSL,P6_2,PALCS,A_3);
PA_3_(PA_3) = AO2A(PALCSL,P6_3,PALCS,A_4);
PA_4_(PA_4) = AO2A(PALCSL,P6_4,PALCS,A_5);
PA_5_(PA_5) = AO2A(PALCSL,P6_5,PALCS,A_6);
PA_6_(PA_6) = AO2A(PALCSL,P6_6,PALCS,A_7);
PA_7_(PA_7) = AO2A(PALCSL,P6_7,PALCS,A_8);
PCS_(PCS) = B3A(RESL);
PWR_(PWR) = NR2C(PALCSL,WRL);
P7_0_(P7L_0) = BTS5A(PED_0,PWR);
P7_1_(P7L_1) = BTS5A(PED_1,PWR);
P7_2_(P7L_2) = BTS5A(PED_2,PWR);
P7_3_(P7L_3) = BTS5A(PED_3,PWR);
P7_4_(P7L_4) = BTS5A(PED_4,PWR);
P7_5_(P7L_5) = BTS5A(PED_5,PWR);
P7_6_(P7L_6) = BTS5A(PED_6,PWR);
P7_7_(P7L_7) = BTS5A(PED_7,PWR);
P7_8_(P7L_8) = BTS5A(D_0,PWR);
P7_9_(P7L_9) = BTS5A(D_1,PWR);
P7_10_(P7L_10) = BTS5A(D_2,PWR);
P7_11_(P7L_11) = BTS5A(D_3,PWR);
P7_12_(P7L_12) = BTS5A(D_4,PWR);
P7_13_(P7L_13) = BTS5A(D_5,PWR);
P7_14_(P7L_14) = BTS5A(D_6,PWR);
P7_15_(P7L_15) = BTS5A(D_7,PWR);
AL_0_(AL_0) = N1A(A_0);
PERD_(PERD) = NR3C(PALCSL,RDL,A_0);
PORD_(PORD) = NR3C(PALCSL,RDL,AL_0);
DE_0_(D_0) = BTS5A(P7L_0,PERD);
DE_1_(D_1) = BTS5A(P7L_1,PERD);
DE_2_(D_2) = BTS5A(P7L_2,PERD);
DE_3_(D_3) = BTS5A(P7L_3,PERD);
DE_4_(D_4) = BTS5A(P7L_4,PERD);
DE_5_(D_5) = BTS5A(P7L_5,PERD);
DE_6_(D_6) = BTS5A(P7L_6,PERD);
DE_7_(D_7) = BTS5A(P7L_7,PERD);
DO_0_(D_0) = BTS5A(P7L_8,PORD);
DO_1_(D_1) = BTS5A(P7L_9,PORD);
DO_2_(D_2) = BTS5A(P7L_10,PORD);
DO_3_(D_3) = BTS5A(P7L_11,PORD);
DO_4_(D_4) = BTS5A(P7L_12,PORD);
DO_5_(D_5) = BTS5A(P7L_13,PORD);
DO_6_(D_6) = BTS5A(P7L_14,PORD);
DO_7_(D_7) = BTS5A(P7L_15,PORD);
POE_(POE) = OR2A(PALCSL,WRL);
PWE_(PWE) = AND3A(PALCS,WE,A_0);
PX7_0_(P7_0) = N1A(P7L_0);
PX7_1_(P7_1) = N1A(P7L_1);
PX7_2_(P7_2) = N1A(P7L_2);
PX7_3_(P7_3) = N1A(P7L_3);
PX7_4_(P7_4) = N1A(P7L_4);
PX7_5_(P7_5) = N1A(P7L_5);
PX7_6_(P7_6) = N1A(P7L_6);
PX7_7_(P7_7) = N1A(P7L_7);
PX7_8_(P7_8) = N1A(P7L_8);
PX7_9_(P7_9) = N1A(P7L_9);
PX7_10_(P7_10) = N1A(P7L_10);
PX7_11_(P7_11) = N1A(P7L_11);
PX7_12_(P7_12) = N1A(P7L_12);
PX7_13_(P7_13) = N1A(P7L_13);
PX7_14_(P7_14) = N1A(P7L_14);
PX7_15_(P7_15) = N1A(P7L_15);

/* blanking and test mode */
/* test mode generates a physical colour directly from the logical */

TMODEL_(TMODEL) = N1A(TMODE);
DATA_(DATA) = NR2C(BLANKING,TMODE);
ADDR_(ADDR) = NR2C(BLANKING,TMODEL);
P8L_0_(P8L_0) = AO2A(DATA,P7_0,ADDR,P6_0);
P8L_1_(P8L_1) = AO2A(DATA,P7_1,ADDR,P6_1);
P8L_2_(P8L_2) = AO2A(DATA,P7_2,ADDR,P6_2);
P8L_3_(P8L_3) = AO2A(DATA,P7_3,ADDR,P6_3);
P8L_4_(P8L_4) = AO2A(DATA,P7_4,ADDR,P6_4);
P8L_5_(P8L_5) = AO2A(DATA,P7_5,ADDR,P6_5);
P8L_6_(P8L_6) = AO2A(DATA,P7_6,ADDR,P6_6);
P8L_7_(P8L_7) = AO2A(DATA,P7_7,ADDR,P6_7);
P8L_8_(P8L_8) = AO2A(DATA,P7_8,ADDR,P6_0);
P8L_9_(P8L_9) = AO2A(DATA,P7_9,ADDR,P6_1);
P8L_10_(P8L_10) = AO2A(DATA,P7_10,ADDR,P6_2);
P8L_11_(P8L_11) = AO2A(DATA,P7_11,ADDR,P6_3);
P8L_12_(P8L_12) = AO2A(DATA,P7_12,ADDR,P6_4);
P8L_13_(P8L_13) = AO2A(DATA,P7_13,ADDR,P6_5);
P8L_14_(P8L_14) = AO2A(DATA,P7_14,ADDR,P6_6);
P8L_15_(P8L_15) = AO2A(DATA,P7_15,ADDR,P6_7);

/* select pixels or border */
/* the border signal is delayed first */

BORDERD_(BORDERD,BORDERDL) = FD2A(BORDER,CLK,RESL);
BLANKINGL_(BLANKINGL) = N1A(BLANKING);
PIXEL_(PIXEL) = ND2C(BORDERD,BLANKINGL);
PIXELL_(PIXELL) = N1C(PIXEL);
P9_0_(P9_0) = AO2A(PIXELL,BCB_0,PIXEL,P8L_0);
P9_1_(P9_1) = AO2A(PIXELL,BCB_1,PIXEL,P8L_1);
P9_2_(P9_2) = AO2A(PIXELL,BCB_2,PIXEL,P8L_2);
P9_3_(P9_3) = AO2A(PIXELL,BCB_3,PIXEL,P8L_3);
P9_4_(P9_4) = AO2A(PIXELL,BCB_4,PIXEL,P8L_4);
P9_5_(P9_5) = AO2A(PIXELL,BCB_5,PIXEL,P8L_5);
P9_6_(P9_6) = AO2A(PIXELL,BCB_6,PIXEL,P8L_6);
P9_7_(P9_7) = AO2A(PIXELL,BCB_7,PIXEL,P8L_7);
P9_8_(P9_8) = AO2A(PIXELL,BCB_8,PIXEL,P8L_8);
P9_9_(P9_9) = AO2A(PIXELL,BCB_9,PIXEL,P8L_9);
P9_10_(P9_10) = AO2A(PIXELL,BCB_10,PIXEL,P8L_10);
P9_11_(P9_11) = AO2A(PIXELL,BCB_11,PIXEL,P8L_11);
P9_12_(P9_12) = AO2A(PIXELL,BCB_12,PIXEL,P8L_12);
P9_13_(P9_13) = AO2A(PIXELL,BCB_13,PIXEL,P8L_13);
P9_14_(P9_14) = AO2A(PIXELL,BCB_14,PIXEL,P8L_14);
P9_15_(P9_15) = AO2A(PIXELL,BCB_15,PIXEL,P8L_15);

/* output latch */

RL_0_(R_0,RL_0) = FD2A(P9_8,CLK,RESL);
RL_1_(R_1,RL_1) = FD2A(P9_9,CLK,RESL);
RL_2_(R_2,RL_2) = FD2A(P9_10,CLK,RESL);
RL_3_(R_3,RL_3) = FD2A(P9_11,CLK,RESL);
GL_0_(G_0,GL_0) = FD2A(P9_4,CLK,RESL);
GL_1_(G_1,GL_1) = FD2A(P9_5,CLK,RESL);
GL_2_(G_2,GL_2) = FD2A(P9_6,CLK,RESL);
GL_3_(G_3,GL_3) = FD2A(P9_7,CLK,RESL);
BL_0_(B_0,BL_0) = FD2A(P9_0,CLK,RESL);
BL_1_(B_1,BL_1) = FD2A(P9_1,CLK,RESL);
BL_2_(B_2,BL_2) = FD2A(P9_2,CLK,RESL);
BL_3_(B_3,BL_3) = FD2A(P9_3,CLK,RESL);

/* latch the mode */

MODE_0_(MODE_0,MODEL_0) = LD1A(WD_0,MODE);
MODE_1_(MODE_1,MODEL_1) = LD1A(WD_1,MODE);
GENLOCK_(GENLOCK,GENLOCKL) = LD1A(WD_2,MODE);
INCEN_(INCEN,INCENL) = LD1A(WD_3,MODE);
BINC_(BINC,BINCL) = LD1A(WD_4,MODE);
HOLD8_(HOLD8,HOLD8L) = LD1A(WD_5,MODE);
VARRES_(VARRES,VARRESL) = LD1A(WD_6,MODE);
WRAP_(NOWRAP,WRAP) = LD1A(WD_7,MODE);

LORES_(LORES) = NR2A(MODE_0,MODE_1);
MEDRES_(MEDRES) = NR2A(MODEL_0,MODE_1);
MEDRESL_(MEDRESL) = N1A(MEDRES);

/* incrust logic */
/* In medium res use bit 7 of each byte, in low and high use bits 3 and 7 */

INCBITL_(INCBITL) = AO2A(MEDRES,P0_7,MEDRESL,P1_3);
BORDERL_(BORDERL) = N1A(BORDER);
INCD_(INCD) = AO2A(BORDER,BINCL,BORDERL,INCBITL);
INC_0_(INC_0) = OR2A(INCD,INCENL);

/* delay by two clock ticks to match the pixel */

INC_1_(INC_1,INCL_1) = FD2A(INC_0,CLK,RESL);
INC_2_(INC_2,INCL_2) = FD2A(INC_1,CLK,RESL);


END MODULE;
END COMPILE;
END;
